;; Author : Ritchie Cai
;; Date   : 2012-12-04
(eval-when (:compile-toplevel :load-toplevel :execute) 
  (set-macro-character #\[ #'(lambda (stream macro-char)
                               (declare (ignore macro-char))
                               (destructuring-bind (h-table h-key)
                                   (read-delimited-list #\] stream t)
                                 `(gethash ,h-key ,h-table))))
  (set-macro-character #\] (get-macro-character #\) ))

  (set-macro-character #\{ #'(lambda (stream macro-char)
                               (declare (ignore macro-char))
                               (let ((pairs (read-delimited-list #\} stream t)))
                                 `(let ((h (make-hash-table :test 'equal)))
                                    (loop :for (key value) :on (list ,@pairs) :by #'cddr
                                       :do (setf (gethash key h) value))
                                    h))))
  (set-macro-character #\} (get-macro-character #\) )))

;; (defun print-table (table)
;;   (maphash #'(lambda (key value)
;;                (format t "~2,,,@a~4,0T: " key)
;;                (format t " zombies   : ~2,,,@a~%" [value :zombies])
;;                (loop
;;                   :initially (format t "~6,0T neighbors :~19,0T")
;;                   :for i :from 0
;;                   ;; :for k :being the :hash-keys of [value :neighbors] :using (hash-value v)
;;                   :for k :in [value :neighbors]
;;                   :if (and (/= i 0)
;;                            (= (mod i 9) 0)) :do (format t "~%~19,0T")
;;                   :do (format t "~2,,,@a:~4,,,a " (first k) (second k))
;;                   :finally (format t "~%"))
;;                (format t "~6,0T exptected : ~a~2&" (float [value :expected])))
;;            table))

(defun print-table (table)
  (format *standard-output* "~a~%" (type-of table))
  (destructuring-bind (rows cols)
      (array-dimensions table)
    (declare (integer rows cols))

    (format *standard-output* "~%~6,0T")
    (dotimes (r cols)
      (format *standard-output* "~4,,,@a " r))
    (format *standard-output* "~%~6,0T")
    (dotimes (r cols)
      (format *standard-output* "~4,,,@a " "----"))
    (format *standard-output* "~%")

    (dotimes (r rows)
      (format *standard-output* "~3,,,@a : ~6,0T" r)
      (dotimes (c cols)
        (format *standard-output* "~4,,,@a " (round (aref table r c))))
      (format *standard-output* "~%"))
    (format *standard-output* "~%")))

(DEFUN read-numbers-from-string (line)
  (when (> (length line) 0)
    (do ((numbers '()) (index 0))
        (())
      (multiple-value-bind (number next)
          (read-from-string line nil nil :start index)
        (if number
            (progn
              (push number numbers)              
              (setq index next))
            (return (nreverse numbers)))))))

(defun q-sort (data)
  (declare (list data))
  (if (<= (length data) 1)
      data
      (let ((pivot (first data)))
        (declare (ratio pivot))
        (append (q-sort (remove-if-not #'(lambda (x) (> x pivot)) data))
                (remove-if-not #'(lambda (x) (= x pivot)) data)
                (q-sort (remove-if-not #'(lambda (x) (< x pivot)) data))))))

(defun qsort-vec (data &key (limit 0))
  (labels ((rec (start end)
             (when (> (- end start) 1)
               (loop :with pivot = start
                  :for ptr from (+ start 1) to (- end 1)
                  :do (when (<= (aref data pivot) (aref data ptr))
                        (when (> (- ptr pivot) 1)
                          (rotatef (aref data (+ pivot 1)) (aref data pivot)))
                        (rotatef (aref data pivot) (aref data ptr))
                        (incf pivot))
                  :finally (progn
                             (rec start pivot)
                             (rec (+ pivot 1) end)))))
           (rec-limit (start end limit)
             (when (> (- end start) 1)
               (loop :with pivot = start and count = 0
                  :for ptr from (+ start 1) to (- end 1)
                  :do (when (<= (aref data pivot) (aref data ptr))
                        (when (> (- ptr pivot) 1)
                          (rotatef (aref data (+ pivot 1)) (aref data pivot)))
                        (rotatef (aref data pivot) (aref data ptr))
                        (incf pivot)
                        (incf count))
                  :finally (if (>= count limit)
                             (rec-limit start pivot limit)
                             (progn
                               (rec-limit start pivot count)
                               (rec-limit (+ pivot 1) end (- limit count 1))))))))
    (if (> limit 0)
        (rec-limit 0 (length data) limit)
        (rec 0 (length data)))))

(defun qsort-colvec (data &key (limit 0))
  (labels ((rec-nx1 (start end limit)
             (when (> (- end start) 1)
               (loop :with pivot = start and count = 0
                  :for ptr from (+ start 1) to (- end 1)
                  :do (when (<= (aref data pivot 0) (aref data ptr 0))
                        (when (> (- ptr pivot) 1)
                          (rotatef (aref data (+ pivot 1) 0) (aref data pivot 0)))
                        (rotatef (aref data pivot 0) (aref data ptr 0))
                        (incf pivot)
                        (incf count))
                  :finally (if (>= count limit)
                             (rec-nx1 start pivot limit)
                             (progn
                               (rec-nx1 start pivot count)
                               (rec-nx1 (+ pivot 1) end (- limit count 1))))))))
    (let ((dimension (array-dimensions data)))
      (if (> limit 0)
          (rec-nx1 0 (first dimension) limit)
          (rec-nx1 0 (first dimension) (first dimension))
          ))))

(defun process-data (input-stream)
  (destructuring-bind (nodes edges steps)
      (read-numbers-from-string (read-line input-stream nil))
    ;; (declare (ignore steps))
    (let ((table      (make-array `(,nodes ,nodes) :element-type 'ratio :initial-element 0))
          (zombies    (make-array `(,nodes 1) :element-type 'ratio :initial-element 0)))

      ;; get edges
      (do ((counter 1 (incf counter)))
          ((> counter edges))
        (let ((pair (read-numbers-from-string (read-line input-stream nil))))
          (setf (aref table (first pair) (second pair)) 1)
          (setf (aref table (second pair) (first pair)) 1)))

      ;; get nodes
      (do ((index 0 (incf index)))
          ((>= index nodes))
        (setf (aref zombies index 0) (read-from-string (read-line input-stream nil))))

      ;; update table
      (dotimes (r nodes)
        (let ((neighbors-count 0))
          (dotimes (c nodes neighbors-count)
            (when (> (aref table r c) 0)
              (incf neighbors-count)))
          (dotimes (i nodes)
            (when (> (aref table i r) 0)
              (setf (aref table i r) (/ 1 neighbors-count))))))

      ;; (print-table table)
      ;; (setq table (array-multiply table (array-multiply table (array-multiply table table))))
      
      ;; run simulation
      (let ((result (simulate table zombies steps)))
        (qsort-colvec result :limit 5)
        (format *standard-output* "~a ~a ~a ~a ~a~%"
                (round (aref result 0 0))
                (round (aref result 1 0))
                (round (aref result 2 0))
                (round (aref result 3 0))
                (round (aref result 4 0))))

      ;; print result
      ;; (destructuring-bind (a1 a2 a3 a4 a5)
      ;;     (map 'list #'round (subseq (q-sort (loop :for key :being the :hash-keys of table
      ;;                                           :using (hash-value node)
      ;;                                           :collect [node :expected])) 0 5))
      ;;   (format *standard-output* "~a ~a ~a ~a ~a~%" a1 a2 a3 a4 a5)
      ;;   (force-output *standard-output*))
      )))

(defun calc-expectations (table)
  (declare (hash-table table))
  (maphash #'(lambda (key node)
               (declare (ignore key) (hash-table node))
               (setf [node :expected] (loop :for (n p) :in [node :neighbors]
                                         :sum (* [[table n] :zombies] p))))
           table))

(defun array-multiply (a b)
  (declare (type (simple-array) a b))
  (let* ((a-dimensions (array-dimensions a))
         (b-dimensions (array-dimensions b))
         (result (make-array `(,(first a-dimensions) ,(second b-dimensions))
                             :element-type 'ratio :initial-element 0)))
    (declare (cons a-dimensions b-dimensions)
             (type (simple-array) result))
    (dotimes (r (first a-dimensions) result)
      (declare (integer r))
      (dotimes (c (second b-dimensions))
        (declare (integer c))
        (let ((value 0))
          (setf (aref result r c)
                (dotimes (k (second a-dimensions) value)
                  (declare (integer k))
                  (incf value (* (aref a r k) (aref b k c))))))))
    (if (= 1 (first a-dimensions) (second b-dimensions))
        (aref result 0 0)
        result)))

(defun max-diffs (a b)
  (declare (type (simple-array) a b))
  (let ((dimensions (array-dimensions a))
        (mdiffs 0))
    (dotimes (r (first dimensions) mdiffs)
      (dotimes (c (second dimensions))
        (let ((diff (abs (- (aref a r c) (aref b r c)))))
        (when (>  diff mdiffs)
          (setf mdiffs diff)))))))

(defun simulate (table zombies ntimes)
  (declare (type (simple-array) zombies)
           (type (simple-array) table)
           (integer ntimes))
  (dotimes (i ntimes zombies)
    (declare (integer i))
    (let ((next-round (array-multiply table zombies)))
      (declare (type (simple-array) next-round))
      (when (< (max-diffs next-round zombies) 1/10)
        (return next-round))
      (setq zombies next-round))))

(defun main ()
  (do ((test-count (read-from-string (read-line *standard-input* nil))
                   (decf test-count)))
      ((= test-count 0))
    (declare (integer test-count))
    (process-data *standard-input*)))

(defun test (filename)
  (with-open-file (in filename :direction :input)
    (do ((test-count (read-from-string (read-line in nil))
                     (decf test-count)))
        ((= test-count 0))
      (declare (integer test-count))
      (process-data in))))
