;; Author : Ritchie Cai
;; Date   : 2012-12-04
(eval-when (:compile-toplevel :load-toplevel :execute) 
  (set-macro-character #\[ #'(lambda (stream macro-char)
                               (declare (ignore macro-char))
                               (destructuring-bind (h-table h-key)
                                   (read-delimited-list #\] stream t)
                                 `(gethash ,h-key ,h-table))))
  (set-macro-character #\] (get-macro-character #\) ))

  (set-macro-character #\{ #'(lambda (stream macro-char)
                               (declare (ignore macro-char))
                               (let ((pairs (read-delimited-list #\} stream t)))
                                 `(let ((h (make-hash-table :test 'equal)))
                                    (loop :for (key value) :on (list ,@pairs) :by #'cddr
                                       :do (setf (gethash key h) value))
                                    h))))
  (set-macro-character #\} (get-macro-character #\) )))

;; (defun print-table (table)
;;   (maphash #'(lambda (key value)
;;                (format t "~2,,,@a~4,0T: " key)
;;                (format t " zombies   : ~2,,,@a~%" [value :zombies])
;;                (loop
;;                   :initially (format t "~6,0T neighbors :~19,0T")
;;                   :for i :from 0
;;                   ;; :for k :being the :hash-keys of [value :neighbors] :using (hash-value v)
;;                   :for k :in [value :neighbors]
;;                   :if (and (/= i 0)
;;                            (= (mod i 9) 0)) :do (format t "~%~19,0T")
;;                   :do (format t "~2,,,@a:~4,,,a " (first k) (second k))
;;                   :finally (format t "~%"))
;;                (format t "~6,0T exptected : ~a~2&" (float [value :expected])))
;;            table))

(defun print-table (table)
  (format *standard-output* "~a~%" (type-of table))
  (destructuring-bind (rows cols)
      (array-dimensions table)
    (declare (integer rows cols))

    (format *standard-output* "~%~6,0T")
    (dotimes (r rows)
      (format *standard-output* "~4,,,@a " r))
    (format *standard-output* "~%~6,0T")
    (dotimes (r rows)
      (format *standard-output* "~4,,,@a " "----"))
    (format *standard-output* "~%")

    (dotimes (r rows)
      (format *standard-output* "~3,,,@a : ~6,0T" r)
      (dotimes (c cols)
        (format *standard-output* "~4,,,@a " (aref table r c)))
      (format *standard-output* "~%"))
    (format *standard-output* "~%")))

(DEFUN read-numbers-from-string (line)
  (when (> (length line) 0)
    (do ((numbers '()) (index 0))
        (())
      (multiple-value-bind (number next)
          (read-from-string line nil nil :start index)
        (if number
            (progn
              (push number numbers)              
              (setq index next))
            (return (nreverse numbers)))))))

(defun q-sort (data)
  (declare (list data))
  (if (<= (length data) 1)
      data
      (let ((pivot (first data)))
        (declare (ratio pivot))
        (append (q-sort (remove-if-not #'(lambda (x) (> x pivot)) data))
                (remove-if-not #'(lambda (x) (= x pivot)) data)
                (q-sort (remove-if-not #'(lambda (x) (< x pivot)) data))))))

(defun process-data (input-stream)
  (destructuring-bind (nodes edges steps)
      (read-numbers-from-string (read-line input-stream nil))
    (declare (ignore steps))
    (let ((table      (make-array `(,nodes ,nodes) :element-type 'ratio :initial-element 0))
          (zombies    (make-array nodes :element-type 'ratio :initial-element 0)))

      ;; get edges
      (do ((counter 1 (incf counter)))
          ((> counter edges))
        (let ((pair (read-numbers-from-string (read-line input-stream nil))))
          (setf (aref table (first pair) (second pair)) 1)
          (setf (aref table (second pair) (first pair)) 1)))

      ;; get nodes
      (do ((index 0 (incf index)))
          ((>= index nodes))
        (setf (aref zombies index) (read-from-string (read-line input-stream nil))))

      ;; update table
      (dotimes (r nodes)
        (let ((neighbors-count 0))
          (dotimes (c nodes neighbors-count)
            (when (> (aref table r c) 0)
              (incf neighbors-count)))
          (dotimes (i nodes)
            (when (> (aref table i r) 0)
              (setf (aref table i r) (/ 1 neighbors-count))))))

      (print-table table)
      (setq table (array-multiply table (array-multiply table (array-multiply table table))))
      
      ;; run simulation
      (simulate table steps)
      
      ;; print result
      ;; (destructuring-bind (a1 a2 a3 a4 a5)
      ;;     (map 'list #'round (subseq (q-sort (loop :for key :being the :hash-keys of table
      ;;                                           :using (hash-value node)
      ;;                                           :collect [node :expected])) 0 5))
      ;;   (format *standard-output* "~a ~a ~a ~a ~a~%" a1 a2 a3 a4 a5)
      ;;   (force-output *standard-output*))
      )))

(defun calc-expectations (table)
  (declare (hash-table table))
  (maphash #'(lambda (key node)
               (declare (ignore key) (hash-table node))
               (setf [node :expected] (loop :for (n p) :in [node :neighbors]
                                         :sum (* [[table n] :zombies] p))))
           table))

(defun array-multiply (a b)
  (declare (type (simple-array) a b))
  (let* ((a-dimensions (array-dimensions a))
         (b-dimensions (array-dimensions b))
         (result (make-array `(,(first a-dimensions) ,(second b-dimensions))
                             :element-type 'ratio :initial-element 0)))
    (declare (cons a-dimensions b-dimensions)
             (type (simple-array) result))
    (dotimes (r (first a-dimensions) result)
      (declare (integer r))
      (dotimes (c (second b-dimensions))
        (declare (integer c))
        (let ((value 0))
          (setf (aref result r c)
                (dotimes (k (second a-dimensions) value)
                  (declare (integer k))
                  (incf value (* (aref a r k) (aref b k c))))))))
    (if (= 1 (first a-dimensions) (second b-dimensions))
        (aref result 0 0)
        result)))

(defun simulate (table zombies ntimes)
  (declare (type (simple-array) zombies)
           (type (simple-array) table)
           (integer ntimes))
  (dotimes (i ntimes zombies)
    (declare (integer i))
    (let ((diffs '())
          (next-round (array-multiply table zombies)))
      (declare (list diffs))
      (if )
      (calc-expectations table)
      (maphash #'(lambda (node content)
                   (declare (ignore node))
                   (push (abs (- [content :expected] [content :zombies])) diffs)
                   (setf [content :zombies] [content :expected]))
               table)
      (when (< (reduce #'max diffs) 1/10) (return))))))

(defun main ()
  (do ((test-count (read-from-string (read-line *standard-input* nil))
                   (decf test-count)))
      ((= test-count 0))
    (declare (integer test-count))
    (process-data *standard-input*)))

(defun test (filename)
  (with-open-file (in filename :direction :input)
    (do ((test-count (read-from-string (read-line in nil))
                     (decf test-count)))
        ((= test-count 0))
      (declare (integer test-count))
      (process-data in))))
